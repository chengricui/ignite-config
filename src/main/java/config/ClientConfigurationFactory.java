package config;

import java.io.InputStream;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Properties;
import javax.cache.configuration.Factory;
import javax.sql.DataSource;
import org.apache.ignite.cache.CacheAtomicityMode;
import org.apache.ignite.cache.CacheMode;
import org.apache.ignite.cache.QueryEntity;
import org.apache.ignite.cache.store.jdbc.CacheJdbcPojoStoreFactory;
import org.apache.ignite.cache.store.jdbc.JdbcType;
import org.apache.ignite.cache.store.jdbc.JdbcTypeField;
import org.apache.ignite.cache.store.jdbc.dialect.BasicJdbcDialect;
import org.apache.ignite.configuration.CacheConfiguration;
import org.apache.ignite.configuration.IgniteConfiguration;
import org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;
import org.apache.ignite.spi.discovery.tcp.ipfinder.multicast.TcpDiscoveryMulticastIpFinder;
import org.postgresql.ds.PGPoolingDataSource;

/** This file was generated by Ignite Web Console (04/27/2019, 18:13) **/
public class ClientConfigurationFactory {
    /** Secret properties loading. **/
    private static final Properties props = new Properties();

    static {
        try (InputStream in = IgniteConfiguration.class.getClassLoader().getResourceAsStream("secret.properties")) {
            props.load(in);
        }
        catch (Exception ignored) {
            // No-op.
        }
    }

    /** Helper class for datasource creation. **/
    public static class DataSources {
        public static final PGPoolingDataSource INSTANCE_dsPostgreSQL_DfmDb = createdsPostgreSQL_DfmDb();

        private static PGPoolingDataSource createdsPostgreSQL_DfmDb() {
            PGPoolingDataSource dsPostgreSQL_DfmDb = new PGPoolingDataSource();

            dsPostgreSQL_DfmDb.setUrl(props.getProperty("dsPostgreSQL_DfmDb.jdbc.url"));
            dsPostgreSQL_DfmDb.setUser(props.getProperty("dsPostgreSQL_DfmDb.jdbc.username"));
            dsPostgreSQL_DfmDb.setPassword(props.getProperty("dsPostgreSQL_DfmDb.jdbc.password"));

            return dsPostgreSQL_DfmDb;
        }
    }

    /**
     * Configure grid.
     * 
     * @return Ignite configuration.
     * @throws Exception If failed to construct Ignite configuration instance.
     **/
    public static IgniteConfiguration createConfiguration() throws Exception {
        IgniteConfiguration cfg = new IgniteConfiguration();

        cfg.setClientMode(true);
        cfg.setIgniteInstanceName("thin-server");

        TcpDiscoverySpi discovery = new TcpDiscoverySpi();

        TcpDiscoveryMulticastIpFinder ipFinder = new TcpDiscoveryMulticastIpFinder();

        ipFinder.setAddresses(Arrays.asList("127.0.0.1:47500..47510"));

        discovery.setIpFinder(ipFinder);

        cfg.setDiscoverySpi(discovery);

        cfg.setCacheConfiguration(
            cacheProductCache(),
            cacheProductTagsCache(),
            cacheProductTypeCache(),
            cachePropertyCache(),
            cachePropertyValueCache(),
            cacheTagCache()
        );

        return cfg;
    }

    /**
     * Create configuration for cache "ProductCache".
     * 
     * @return Configured cache.
     * @throws Exception if failed to create cache configuration.
     **/
    public static CacheConfiguration cacheProductCache() throws Exception {
        CacheConfiguration ccfg = new CacheConfiguration();

        ccfg.setName("ProductCache");
        ccfg.setCacheMode(CacheMode.PARTITIONED);
        ccfg.setAtomicityMode(CacheAtomicityMode.ATOMIC);

        CacheJdbcPojoStoreFactory cacheStoreFactory = new CacheJdbcPojoStoreFactory();

        cacheStoreFactory.setDataSourceFactory(new Factory<DataSource>() {
            /** {@inheritDoc} **/
            @Override public DataSource create() {
                return DataSources.INSTANCE_dsPostgreSQL_DfmDb;
            };
        });

        cacheStoreFactory.setDialect(new BasicJdbcDialect());

        cacheStoreFactory.setTypes(jdbcTypeProduct(ccfg.getName()));

        ccfg.setCacheStoreFactory(cacheStoreFactory);

        ccfg.setReadThrough(true);
        ccfg.setWriteThrough(true);

        ArrayList<QueryEntity> qryEntities = new ArrayList<>();

        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("java.lang.Long");
        qryEntity.setValueType("com.dfm.thin.model.Product");
        qryEntity.setKeyFieldName("id");

        HashSet<String> keyFields = new HashSet<>();

        keyFields.add("id");

        qryEntity.setKeyFields(keyFields);

        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("description", "java.lang.String");
        fields.put("name", "java.lang.String");
        fields.put("url", "java.lang.String");
        fields.put("typeId", "java.lang.Long");
        fields.put("id", "java.lang.Long");

        qryEntity.setFields(fields);

        HashMap<String, String> aliases = new HashMap<>();

        aliases.put("typeId", "type_id");

        qryEntity.setAliases(aliases);
        qryEntities.add(qryEntity);

        ccfg.setQueryEntities(qryEntities);

        return ccfg;
    }

    /**
     * Create JDBC type for "jdbcTypeProduct".
     * 
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     **/
    private static JdbcType jdbcTypeProduct(String cacheName) {
        JdbcType type = new JdbcType();

        type.setCacheName(cacheName);
        type.setKeyType(Long.class);
        type.setValueType("com.dfm.thin.model.Product");
        type.setDatabaseSchema("public");
        type.setDatabaseTable("product");

        type.setKeyFields(new JdbcTypeField(Types.BIGINT, "id", long.class, "id"));

        type.setValueFields(
            new JdbcTypeField(Types.VARCHAR, "description", String.class, "description"),
            new JdbcTypeField(Types.VARCHAR, "name", String.class, "name"),
            new JdbcTypeField(Types.VARCHAR, "url", String.class, "url"),
            new JdbcTypeField(Types.BIGINT, "type_id", long.class, "typeId"),
            new JdbcTypeField(Types.BIGINT, "id", long.class, "id")
        );

        return type;
    }

    /**
     * Create configuration for cache "ProductTagsCache".
     * 
     * @return Configured cache.
     * @throws Exception if failed to create cache configuration.
     **/
    public static CacheConfiguration cacheProductTagsCache() throws Exception {
        CacheConfiguration ccfg = new CacheConfiguration();

        ccfg.setName("ProductTagsCache");
        ccfg.setCacheMode(CacheMode.PARTITIONED);
        ccfg.setAtomicityMode(CacheAtomicityMode.ATOMIC);

        CacheJdbcPojoStoreFactory cacheStoreFactory = new CacheJdbcPojoStoreFactory();

        cacheStoreFactory.setDataSourceFactory(new Factory<DataSource>() {
            /** {@inheritDoc} **/
            @Override public DataSource create() {
                return DataSources.INSTANCE_dsPostgreSQL_DfmDb;
            };
        });

        cacheStoreFactory.setDialect(new BasicJdbcDialect());

        cacheStoreFactory.setTypes(jdbcTypeProductTags(ccfg.getName()));

        ccfg.setCacheStoreFactory(cacheStoreFactory);

        ccfg.setReadThrough(true);
        ccfg.setWriteThrough(true);

        ArrayList<QueryEntity> qryEntities = new ArrayList<>();

        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("com.dfm.thin.model.ProductTagsKey");
        qryEntity.setValueType("com.dfm.thin.model.ProductTags");
        qryEntity.setTableName("product_tags");

        HashSet<String> keyFields = new HashSet<>();

        keyFields.add("productId");

        keyFields.add("tagId");

        qryEntity.setKeyFields(keyFields);

        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("productId", "java.lang.Long");
        fields.put("tagId", "java.lang.Long");

        qryEntity.setFields(fields);

        HashMap<String, String> aliases = new HashMap<>();

        aliases.put("productId", "product_id");
        aliases.put("tagId", "tag_id");

        qryEntity.setAliases(aliases);
        qryEntities.add(qryEntity);

        ccfg.setQueryEntities(qryEntities);

        return ccfg;
    }

    /**
     * Create JDBC type for "jdbcTypeProductTags".
     * 
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     **/
    private static JdbcType jdbcTypeProductTags(String cacheName) {
        JdbcType type = new JdbcType();

        type.setCacheName(cacheName);
        type.setKeyType("com.dfm.thin.model.ProductTagsKey");
        type.setValueType("com.dfm.thin.model.ProductTags");
        type.setDatabaseSchema("public");
        type.setDatabaseTable("product_tags");

        type.setKeyFields(
            new JdbcTypeField(Types.BIGINT, "product_id", long.class, "productId"),
            new JdbcTypeField(Types.BIGINT, "tag_id", long.class, "tagId")
        );

        type.setValueFields(
            new JdbcTypeField(Types.BIGINT, "product_id", long.class, "productId"),
            new JdbcTypeField(Types.BIGINT, "tag_id", long.class, "tagId")
        );

        return type;
    }

    /**
     * Create configuration for cache "ProductTypeCache".
     * 
     * @return Configured cache.
     * @throws Exception if failed to create cache configuration.
     **/
    public static CacheConfiguration cacheProductTypeCache() throws Exception {
        CacheConfiguration ccfg = new CacheConfiguration();

        ccfg.setName("ProductTypeCache");
        ccfg.setCacheMode(CacheMode.PARTITIONED);
        ccfg.setAtomicityMode(CacheAtomicityMode.ATOMIC);

        CacheJdbcPojoStoreFactory cacheStoreFactory = new CacheJdbcPojoStoreFactory();

        cacheStoreFactory.setDataSourceFactory(new Factory<DataSource>() {
            /** {@inheritDoc} **/
            @Override public DataSource create() {
                return DataSources.INSTANCE_dsPostgreSQL_DfmDb;
            };
        });

        cacheStoreFactory.setDialect(new BasicJdbcDialect());

        cacheStoreFactory.setTypes(jdbcTypeProductType(ccfg.getName()));

        ccfg.setCacheStoreFactory(cacheStoreFactory);

        ccfg.setReadThrough(true);
        ccfg.setWriteThrough(true);

        ArrayList<QueryEntity> qryEntities = new ArrayList<>();

        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("java.lang.Long");
        qryEntity.setValueType("com.dfm.thin.model.ProductType");
        qryEntity.setTableName("product_type");
        qryEntity.setKeyFieldName("id");

        HashSet<String> keyFields = new HashSet<>();

        keyFields.add("id");

        qryEntity.setKeyFields(keyFields);

        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("description", "java.lang.String");
        fields.put("name", "java.lang.String");
        fields.put("id", "java.lang.Long");

        qryEntity.setFields(fields);
        qryEntities.add(qryEntity);

        ccfg.setQueryEntities(qryEntities);

        return ccfg;
    }

    /**
     * Create JDBC type for "jdbcTypeProductType".
     * 
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     **/
    private static JdbcType jdbcTypeProductType(String cacheName) {
        JdbcType type = new JdbcType();

        type.setCacheName(cacheName);
        type.setKeyType(Long.class);
        type.setValueType("com.dfm.thin.model.ProductType");
        type.setDatabaseSchema("public");
        type.setDatabaseTable("product_type");

        type.setKeyFields(new JdbcTypeField(Types.BIGINT, "id", long.class, "id"));

        type.setValueFields(
            new JdbcTypeField(Types.VARCHAR, "description", String.class, "description"),
            new JdbcTypeField(Types.VARCHAR, "name", String.class, "name"),
            new JdbcTypeField(Types.BIGINT, "id", long.class, "id")
        );

        return type;
    }

    /**
     * Create configuration for cache "PropertyCache".
     * 
     * @return Configured cache.
     * @throws Exception if failed to create cache configuration.
     **/
    public static CacheConfiguration cachePropertyCache() throws Exception {
        CacheConfiguration ccfg = new CacheConfiguration();

        ccfg.setName("PropertyCache");
        ccfg.setCacheMode(CacheMode.PARTITIONED);
        ccfg.setAtomicityMode(CacheAtomicityMode.ATOMIC);

        CacheJdbcPojoStoreFactory cacheStoreFactory = new CacheJdbcPojoStoreFactory();

        cacheStoreFactory.setDataSourceFactory(new Factory<DataSource>() {
            /** {@inheritDoc} **/
            @Override public DataSource create() {
                return DataSources.INSTANCE_dsPostgreSQL_DfmDb;
            };
        });

        cacheStoreFactory.setDialect(new BasicJdbcDialect());

        cacheStoreFactory.setTypes(jdbcTypeProperty(ccfg.getName()));

        ccfg.setCacheStoreFactory(cacheStoreFactory);

        ccfg.setReadThrough(true);
        ccfg.setWriteThrough(true);

        ArrayList<QueryEntity> qryEntities = new ArrayList<>();

        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("java.lang.Long");
        qryEntity.setValueType("com.dfm.thin.model.Property");
        qryEntity.setKeyFieldName("id");

        HashSet<String> keyFields = new HashSet<>();

        keyFields.add("id");

        qryEntity.setKeyFields(keyFields);

        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("name", "java.lang.String");
        fields.put("type", "java.lang.String");
        fields.put("propertyId", "java.lang.Long");
        fields.put("id", "java.lang.Long");

        qryEntity.setFields(fields);

        HashMap<String, String> aliases = new HashMap<>();

        aliases.put("propertyId", "property_id");

        qryEntity.setAliases(aliases);
        qryEntities.add(qryEntity);

        ccfg.setQueryEntities(qryEntities);

        return ccfg;
    }

    /**
     * Create JDBC type for "jdbcTypeProperty".
     * 
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     **/
    private static JdbcType jdbcTypeProperty(String cacheName) {
        JdbcType type = new JdbcType();

        type.setCacheName(cacheName);
        type.setKeyType(Long.class);
        type.setValueType("com.dfm.thin.model.Property");
        type.setDatabaseSchema("public");
        type.setDatabaseTable("property");

        type.setKeyFields(new JdbcTypeField(Types.BIGINT, "id", long.class, "id"));

        type.setValueFields(
            new JdbcTypeField(Types.VARCHAR, "name", String.class, "name"),
            new JdbcTypeField(Types.VARCHAR, "type", String.class, "type"),
            new JdbcTypeField(Types.BIGINT, "property_id", long.class, "propertyId"),
            new JdbcTypeField(Types.BIGINT, "id", long.class, "id")
        );

        return type;
    }

    /**
     * Create configuration for cache "PropertyValueCache".
     * 
     * @return Configured cache.
     * @throws Exception if failed to create cache configuration.
     **/
    public static CacheConfiguration cachePropertyValueCache() throws Exception {
        CacheConfiguration ccfg = new CacheConfiguration();

        ccfg.setName("PropertyValueCache");
        ccfg.setCacheMode(CacheMode.PARTITIONED);
        ccfg.setAtomicityMode(CacheAtomicityMode.ATOMIC);

        CacheJdbcPojoStoreFactory cacheStoreFactory = new CacheJdbcPojoStoreFactory();

        cacheStoreFactory.setDataSourceFactory(new Factory<DataSource>() {
            /** {@inheritDoc} **/
            @Override public DataSource create() {
                return DataSources.INSTANCE_dsPostgreSQL_DfmDb;
            };
        });

        cacheStoreFactory.setDialect(new BasicJdbcDialect());

        cacheStoreFactory.setTypes(jdbcTypePropertyValue(ccfg.getName()));

        ccfg.setCacheStoreFactory(cacheStoreFactory);

        ccfg.setReadThrough(true);
        ccfg.setWriteThrough(true);

        ArrayList<QueryEntity> qryEntities = new ArrayList<>();

        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("java.lang.Long");
        qryEntity.setValueType("com.dfm.thin.model.PropertyValue");
        qryEntity.setTableName("property_value");
        qryEntity.setKeyFieldName("id");

        HashSet<String> keyFields = new HashSet<>();

        keyFields.add("id");

        qryEntity.setKeyFields(keyFields);

        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("value", "java.lang.String");
        fields.put("propertyId", "java.lang.Long");
        fields.put("id", "java.lang.Long");

        qryEntity.setFields(fields);

        HashMap<String, String> aliases = new HashMap<>();

        aliases.put("propertyId", "property_id");

        qryEntity.setAliases(aliases);
        qryEntities.add(qryEntity);

        ccfg.setQueryEntities(qryEntities);

        return ccfg;
    }

    /**
     * Create JDBC type for "jdbcTypePropertyValue".
     * 
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     **/
    private static JdbcType jdbcTypePropertyValue(String cacheName) {
        JdbcType type = new JdbcType();

        type.setCacheName(cacheName);
        type.setKeyType(Long.class);
        type.setValueType("com.dfm.thin.model.PropertyValue");
        type.setDatabaseSchema("public");
        type.setDatabaseTable("property_value");

        type.setKeyFields(new JdbcTypeField(Types.BIGINT, "id", long.class, "id"));

        type.setValueFields(
            new JdbcTypeField(Types.VARCHAR, "value", String.class, "value"),
            new JdbcTypeField(Types.BIGINT, "property_id", long.class, "propertyId"),
            new JdbcTypeField(Types.BIGINT, "id", long.class, "id")
        );

        return type;
    }

    /**
     * Create configuration for cache "TagCache".
     * 
     * @return Configured cache.
     * @throws Exception if failed to create cache configuration.
     **/
    public static CacheConfiguration cacheTagCache() throws Exception {
        CacheConfiguration ccfg = new CacheConfiguration();

        ccfg.setName("TagCache");
        ccfg.setCacheMode(CacheMode.PARTITIONED);
        ccfg.setAtomicityMode(CacheAtomicityMode.ATOMIC);

        CacheJdbcPojoStoreFactory cacheStoreFactory = new CacheJdbcPojoStoreFactory();

        cacheStoreFactory.setDataSourceFactory(new Factory<DataSource>() {
            /** {@inheritDoc} **/
            @Override public DataSource create() {
                return DataSources.INSTANCE_dsPostgreSQL_DfmDb;
            };
        });

        cacheStoreFactory.setDialect(new BasicJdbcDialect());

        cacheStoreFactory.setTypes(jdbcTypeTag(ccfg.getName()));

        ccfg.setCacheStoreFactory(cacheStoreFactory);

        ccfg.setReadThrough(true);
        ccfg.setWriteThrough(true);

        ArrayList<QueryEntity> qryEntities = new ArrayList<>();

        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("java.lang.Long");
        qryEntity.setValueType("com.dfm.thin.model.Tag");
        qryEntity.setKeyFieldName("id");

        HashSet<String> keyFields = new HashSet<>();

        keyFields.add("id");

        qryEntity.setKeyFields(keyFields);

        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("value", "java.lang.String");
        fields.put("id", "java.lang.Long");

        qryEntity.setFields(fields);
        qryEntities.add(qryEntity);

        ccfg.setQueryEntities(qryEntities);

        return ccfg;
    }

    /**
     * Create JDBC type for "jdbcTypeTag".
     * 
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     **/
    private static JdbcType jdbcTypeTag(String cacheName) {
        JdbcType type = new JdbcType();

        type.setCacheName(cacheName);
        type.setKeyType(Long.class);
        type.setValueType("com.dfm.thin.model.Tag");
        type.setDatabaseSchema("public");
        type.setDatabaseTable("tag");

        type.setKeyFields(new JdbcTypeField(Types.BIGINT, "id", long.class, "id"));

        type.setValueFields(
            new JdbcTypeField(Types.VARCHAR, "value", String.class, "value"),
            new JdbcTypeField(Types.BIGINT, "id", long.class, "id")
        );

        return type;
    }
}